# 总结和补充

# 装饰器（decorator）

ES7提案装饰器

装饰器：用于为类、类成员、参数添加元数据(metadata)信息。

元数据：修饰数据的数据

使用方式：在类、类成员、参数前面加上```@装饰器名称```

在JS中，装饰器本质上是一个带有参数的函数，根据修饰的目标不同，对函数的参数有不同的要求

1. 类装饰器

函数，该函数必须有一个参数，表示修饰的目标类

2. 属性装饰器

函数，该函数必须有三个参数，分别表示修饰的目标类的原型、修饰的属性名

# 补充ES5

> 类、原型、原型链、继承；

> 执行上下文

> 事件循环

## 执行上下文

执行上下文本质上是一块内存空间，该空间在函数**调用**的时候创建，该空间存放的信息会为函数的执行提供支持，函数**调用结束**后，空间被销毁。

**执行上下文堆栈**：js程序执行时，有一块内存空间，该空间中存放的是当前函数的执行上下文。

加入到执行上下文堆栈的过程，叫做**入栈**

从执行上下文堆栈中销毁的过程，叫做**出栈**

堆栈的特点：先入后出，后入先出

执行上下文堆栈的底部，是**全局执行上下文**

JS引擎，始终执行的是**执行上下文堆栈**中最顶部的函数

**执行上下文中有哪些内容？**

- 参数
- 字面量函数声明，若执行上下文中已存在相应的数据，则使用函数将其覆盖
- 局部变量，若执行上下文中已存在相应的数据，则不做任何处理
- 作用域链
- this

> 死循环会不会导致内存溢出：不会；无限递归会导致内存溢出。

## 事件循环

- 执行上下文堆栈
- 环境API调用（宿主环境，settimeout、setinterval、ajax、文件读写等等）
- 事件队列（存放函数，其中的函数，来自于api调用结束后的回调）

什么时候程序运行结束？当以上三个区域没有任何内容时，程序执行结束。

当执行上下文堆栈中已不存在任何可以执行的东西的时候，会从事件队列中取出第一个函数执行。

JS代码不会中断函数的执行。

# sass

sass是一个css预编译器，能够让我们使用简洁优雅的代码书写样式，它会把书写的样式编译成为css。

css的问题：

- 数值重复

```css
.container{
    width:500px;
    height:500px;
}

.contianer .content{
    width:500px;
    height:500px;
}
```

- 使用选择器组合时，会出现大量的重复代码

- 重复的代码块

```css
.div1{
    display:flex;
    justify-content:center;
    align-items:center;
}

.div2{
    display:flex;
    justify-content:center;
    align-items:center;
}
```

sass开发环境：koala