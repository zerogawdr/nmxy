# 更多的类型约束 {ignore=true}

> 前端：激进
> 使用TS的准则：一切以缩减项目时间为准
> TS的类型检查：编译期间

# 字面量约束

使用一个字面量作为类型约束

常见的字面量约束：

1. 字符串
2. 数字
3. 对象
4. 函数

使用字符串和数字，配合联合类型，可以对某些变量的取值范围进行约束

但是这样的约束有以下的问题：

1. 如果代码中，出现多个地方需要相同的约束，会导致大量重复代码
2. 使用字面量约束时，逻辑名称和真实名称是相同的，如果真实名称需要修改时，会导致大量的修改。
3. 特点：字面量约束不会出现在编译结果中，因此，如果要在运行的过程中，动态的获取到字面量约束，是不可能的。

使用字面量约束的场景：

1. 代码中极少量的重复约束
2. 几乎永远不会修改其字面量内容（真实名称）
3. 永远不会在运行时动态获取

# 枚举

专门用于约束某个变量的取值范围

枚举属于自定义类型，定义时使用```enum```关键字

每个枚举表示一个新的类型，枚举中可以有多个字段，每个字段由字段名（逻辑名称）和字段值（真实名称）

枚举的特点：

1. 可以解决重复类型约束的问题
2. 可以解决逻辑名称和真是名称重叠的问题
3. 枚举会出现在编译结果中，会变为一个普通的JS对象
4. 枚举的每一个字段，可以取值为字符串 或 数字，如果不给字段赋值，默认为数字, 从0开始，依次自增

> 注意：一个枚举中，不要即出现字符串字段值，同时出现数字字段值

> 如果是一个数字枚举，允许你赋值为超越范围的数字值。

> any可以赋值给任何类型

枚举的骚操作：枚举的位运算

位运算：两个数字（整数），将它们的二进制格式进行运算

# TS中的类

TS中，类的成员不可以随意添加

TS中，可以使用一些修饰符，来修饰类成员

- readonly: 被该修饰符修饰的属性，完成初始化后，不可更改

TS在类里面，提供了访问器，每个访问器是两个函数，一个为get、一个为set，当给某个属性赋值的时候，运行set；而读取某个属性的时候，会运行get。

- get：被该修饰符修饰的函数，函数名会被当成属性名，读取该属性时，将运行该函数，并将函数的返回结果当作属性的值。
- set: 被改修饰符修饰的函数，函数名会被当成属性名，设置改属性值时，会运行改函数，并把设置的值当作参数传入

TS提供了三种访问修饰符，被修饰的资源具有访问权限：

- public（默认值）：公开的。所有的代码均可访问
- private: 私有的，只有成员所在的类中可以访问，在JS中，可以使用ES6提供的Symbol来完成类似功能
- protected: 受保护的，只有自身和子类中可以访问。


关于继承：

类之间可能出现继承关系，比如：动物和猫科动物，猫科动物和猫

动物是父类，猫科动物是子类，猫科动物继承自动物，动物派生猫科动物， 猫科动物是派生类

猫科动物是父类，猫是子类，猫继承自猫科动物，猫科动物派生猫， 猫是派生类

子类拥有父类的所有特征（成员），父类不一定拥有子类的特征（成员）

子类拥有父类的所有公共成员

面向对象中，关于继承的强制规则：子类的构造函数的第一行，必须要调用父类的构造函数

关键字```super```表示父类

# 函数的重载

类型断言：在某些情况下，我可以确定的知道某个变量一定是某个类型，但TS类型系统不确定，此时，可以使用类型断言强制告诉TS，该变量一定是某个类型

在TS中，可以使用函数重载，来更加精细的表达函数可能出现的各种参数或返回值组合